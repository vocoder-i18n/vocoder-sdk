/** Runtime loading for manifest and locale modules generated by `vocoder sync`. */

import type { LocalesMap, TranslationsMap } from './types';

interface VocoderConfig {
  sourceLocale: string;
  targetLocales: string[];
  locales: LocalesMap;
}

interface VocoderManifest {
  config: VocoderConfig;
  loaders: Record<string, () => any>;
}

const emptyConfig: VocoderConfig = {
  sourceLocale: '',
  targetLocales: [],
  locales: {},
};

let _config: VocoderConfig = emptyConfig;
let _loadedTranslations: TranslationsMap = {};
let _loaders: Record<string, () => any> = {};
let _manifestLoaded = false;
let _manifestLoadPromise: Promise<VocoderManifest | null> | null = null;

// Load CJS manifest during server startup.
try {
  if (typeof window === 'undefined' && typeof require !== 'undefined') {
    const mod = require('@vocoder/generated/manifest.cjs');
    const manifest = (mod?.default ?? mod) as VocoderManifest;

    if (manifest?.config) {
      _config = manifest.config;
    }
    if (manifest?.loaders) {
      _loaders = manifest.loaders;
    }

    _manifestLoaded = true;
  }
} catch {
  // Generated files are optional at startup.
}

// Load ESM manifest in browser/bundler environments.
async function loadManifest(): Promise<VocoderManifest | null> {
  if (_manifestLoaded) {
    return _config.sourceLocale ? { config: _config, loaders: _loaders } : null;
  }
  if (_manifestLoadPromise) {
    return _manifestLoadPromise;
  }

  _manifestLoadPromise = (async () => {
    try {
      const mod = await import('@vocoder/generated/manifest');
      const manifest = (mod.default ?? mod) as VocoderManifest;

      if (manifest?.config) {
        _config = manifest.config;
      }
      if (manifest?.loaders) {
        _loaders = manifest.loaders;
      }
      _manifestLoaded = true;

      return manifest;
    } catch {
      return null;
    } finally {
      _manifestLoadPromise = null;
    }
  })();

  return _manifestLoadPromise;
}

function getInitialLocale(): string {
  if (!_config.sourceLocale) {
    return '';
  }

  if (typeof document !== 'undefined') {
    const cookieMatch = document.cookie.match(/vocoder_locale=([^;]+)/);
    const cookieLocale = cookieMatch?.[1];
    if (cookieLocale && _config.locales[cookieLocale]) {
      return cookieLocale;
    }
  }

  if (typeof window !== 'undefined' && window.localStorage) {
    try {
      const storageLocale = localStorage.getItem('vocoder_locale');
      if (storageLocale && _config.locales[storageLocale]) {
        return storageLocale;
      }
    } catch {
      // Ignore blocked storage access.
    }
  }

  return _config.sourceLocale;
}

if (typeof window === 'undefined' && typeof require !== 'undefined') {
  const initialLocale = getInitialLocale();
  if (initialLocale && _loaders[initialLocale]) {
    try {
      const mod = _loaders[initialLocale]!();
      const translations = (mod as any)?.default ?? mod;
      _loadedTranslations[initialLocale] = translations || {};
    } catch {
      // Keep empty translations for this locale.
    }
  }
}

/** Initialize manifest and initial locale on the client. */
export async function initializeVocoder(): Promise<void> {
  await loadManifest();

  if (!_config.sourceLocale) return;

  const initialLocale = getInitialLocale();
  if (initialLocale && !_loadedTranslations[initialLocale]) {
    await loadLocale(initialLocale);
  }
}

export function getGeneratedConfig(): VocoderConfig {
  return _config;
}

export function getGeneratedTranslations(): TranslationsMap {
  return _loadedTranslations;
}

export function getGeneratedLocales(): LocalesMap {
  return _config.locales;
}

/** Load locale translations via manifest loader. */
export async function loadLocale(locale: string): Promise<Record<string, string>> {
  if (_loadedTranslations[locale]) {
    return _loadedTranslations[locale]!;
  }

  if (!_manifestLoaded) {
    await loadManifest();
  }

  if (_loaders[locale]) {
    try {
      const mod = _loaders[locale]!();
      const resolved = (mod as any)?.then ? await mod : mod;
      const translations = resolved?.default ?? resolved;
      _loadedTranslations[locale] = translations || {};
      return _loadedTranslations[locale]!;
    } catch (error) {
      console.error(`Failed to load translations via manifest for locale: ${locale}`, error);
    }
  }

  console.error(`Failed to load translations for locale: ${locale} - no loader available`);
  return {};
}

/** Load a locale synchronously on the server via CJS loader. */
export function loadLocaleSync(locale: string): Record<string, string> | null {
  if (typeof window !== 'undefined') return null;
  if (_loadedTranslations[locale]) return _loadedTranslations[locale]!;
  if (!_manifestLoaded && typeof require !== 'undefined') {
    try {
      const mod = require('@vocoder/generated/manifest.cjs');
      const manifest = (mod?.default ?? mod) as VocoderManifest;
      if (manifest?.config) {
        _config = manifest.config;
      }
      if (manifest?.loaders) {
        _loaders = manifest.loaders;
      }
      _manifestLoaded = true;
    } catch {
      return null;
    }
  }
  if (!_manifestLoaded) return null;
  const loader = _loaders[locale];
  if (!loader) return null;

  try {
    const mod = loader();
    if ((mod as any)?.then) return null;
    const translations = (mod as any)?.default ?? mod;
    if (translations && typeof translations === 'object') {
      _loadedTranslations[locale] = translations;
      return _loadedTranslations[locale]!;
    }
  } catch {
    return null;
  }

  return null;
}
