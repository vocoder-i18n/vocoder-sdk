import type { ProjectConfig, TranslateOptions } from '../types.js';
import { detectBranch, isTargetBranch } from '../utils/branch.js';
import { getLocalConfig, getMergedConfig, validateLocalConfig } from '../utils/config.js';
import { mkdirSync, writeFileSync } from 'fs';

import { StringExtractor } from '../utils/extract.js';
import { VocoderAPI } from '../utils/api.js';
import chalk from 'chalk';
import { join } from 'path';
import ora from 'ora';

/**
 * Generate a self-contained CJS module with all translation data.
 * This gets written to a hidden cache directory
 */
/**
 * Generate config.js with locale metadata
 */
function generateConfigModule(
  projectConfig: { sourceLocale: string; targetLocales: string[] },
  localeMetadata?: Record<string, { nativeName: string; dir?: 'rtl' }>
): string {
  const allLocales = [projectConfig.sourceLocale, ...projectConfig.targetLocales];

  // Build locales metadata object
  const localesObj: Record<string, { nativeName: string; dir?: string }> = {};
  for (const locale of allLocales) {
    const metadata = localeMetadata?.[locale];
    if (metadata) {
      localesObj[locale] = { nativeName: metadata.nativeName };
      if (metadata.dir) {
        localesObj[locale].dir = metadata.dir;
      }
    } else {
      localesObj[locale] = { nativeName: locale };
    }
  }

  return `// Auto-generated by \`npx vocoder sync\` ‚Äî do not edit
// Configuration and locale metadata
module.exports = {
  sourceLocale: ${JSON.stringify(projectConfig.sourceLocale)},
  targetLocales: ${JSON.stringify(projectConfig.targetLocales)},
  locales: ${JSON.stringify(localesObj, null, 2)},
};
`;
}

/**
 * Generate individual locale translation file
 */
function generateLocaleModule(
  locale: string,
  translations: Record<string, string>
): string {
  return `// Auto-generated by \`npx vocoder sync\` ‚Äî do not edit
// Translations for locale: ${locale}
module.exports = ${JSON.stringify(translations, null, 2)};
`;
}

/**
 * Main sync command
 *
 * Workflow:
 * 1. Detect branch
 * 2. Load project config
 * 3. Check if target branch (skip if not)
 * 4. Extract strings from source code
 * 5. Submit to API for translation
 * 6. Poll for completion
 * 7. Write translations to cache
 */
export async function sync(options: TranslateOptions = {}): Promise<void> {
  const startTime = Date.now();
  const projectRoot = process.cwd();

  try {
    // 1. Detect branch
    const spinner = ora('Detecting branch...').start();
    const branch = detectBranch(options.branch);
    spinner.succeed(`Detected branch: ${chalk.cyan(branch)}`);

    // 2. Load merged configuration from all sources
    spinner.start('Loading project configuration...');

    const mergedConfig = await getMergedConfig(options, options.verbose);

    // Build local config with merged values
    const localConfig = getLocalConfig();
    if (mergedConfig.apiKey) {
      localConfig.apiKey = mergedConfig.apiKey;
    }
    if (mergedConfig.apiUrl) {
      localConfig.apiUrl = mergedConfig.apiUrl;
    }

    validateLocalConfig(localConfig);

    const api = new VocoderAPI(localConfig);
    const apiConfig = await api.getProjectConfig();

    // Merge local and API config
    const config: ProjectConfig = {
      ...localConfig,
      ...apiConfig,
      extractionPattern: mergedConfig.extractionPattern,
      excludePattern: mergedConfig.excludePattern,
      timeout: 60000,
    };

    spinner.succeed('Project configuration loaded');

    // 3. Check if target branch
    if (!options.force && !isTargetBranch(branch, config.targetBranches)) {
      console.log(
        chalk.yellow(
          `‚ÑπÔ∏è  Skipping translations (${branch} is not a target branch)`,
        ),
      );
      console.log(
        chalk.dim(
          `   Target branches: ${config.targetBranches.join(', ')}`,
        ),
      );
      console.log(chalk.dim(`   Use --force to translate anyway`));
      process.exit(0);
    }

    // 4. Extract strings
    const patternsDisplay = Array.isArray(config.extractionPattern)
      ? config.extractionPattern.join(', ')
      : config.extractionPattern;

    spinner.start(`Extracting strings from ${patternsDisplay}...`);
    const extractor = new StringExtractor();
    const extractedStrings = await extractor.extractFromProject(
      config.extractionPattern,
      projectRoot,
      config.excludePattern,
    );

    if (extractedStrings.length === 0) {
      spinner.warn('No translatable strings found');
      console.log(chalk.yellow('Make sure you are using <T> components from @vocoder/react'));
      process.exit(0);
    }

    spinner.succeed(
      `Extracted ${chalk.cyan(extractedStrings.length)} strings from ${chalk.cyan(patternsDisplay)}`,
    );

    // Show sample strings in verbose mode
    if (options.verbose) {
      console.log(chalk.dim('\nSample strings:'));
      extractedStrings.slice(0, 5).forEach((s) => {
        console.log(chalk.dim(`  - "${s.text}" (${s.file}:${s.line})`));
      });
      if (extractedStrings.length > 5) {
        console.log(chalk.dim(`  ... and ${extractedStrings.length - 5} more`));
      }
      console.log();
    }

    // Dry run mode - stop here
    if (options.dryRun) {
      console.log(chalk.cyan('\nüìã Dry run mode - would translate:'));
      console.log(chalk.dim(`   Strings: ${extractedStrings.length}`));
      console.log(chalk.dim(`   Branch: ${branch}`));
      console.log(chalk.dim(`   Target locales: ${config.targetLocales.join(', ')}`));
      console.log(chalk.dim(`\n   No API calls made.`));
      process.exit(0);
    }

    // 5. Submit to API
    spinner.start('Submitting strings to Vocoder API...');

    const strings = extractedStrings.map((s) => s.text);
    const batchResponse = await api.submitTranslation(
      branch,
      strings,
      config.targetLocales,
    );

    spinner.succeed(
      `Submitted to API - Batch ID: ${chalk.cyan(batchResponse.batchId)}`,
    );

    // Handle UP_TO_DATE status (hash matched, no changes)
    if (batchResponse.status === 'UP_TO_DATE' && batchResponse.noChanges) {
      console.log(chalk.green('\n‚úî No changes detected - strings are up to date'));
    }

    // Display diff metrics
    console.log(
      chalk.dim(
        `   New strings: ${chalk.cyan(batchResponse.newStrings)}`,
      ),
    );

    if (batchResponse.deletedStrings && batchResponse.deletedStrings > 0) {
      console.log(
        chalk.dim(
          `   Deleted strings: ${chalk.yellow(batchResponse.deletedStrings)} (archived)`,
        ),
      );
    }

    console.log(
      chalk.dim(
        `   Total strings: ${chalk.cyan(batchResponse.totalStrings)}`,
      ),
    );

    if (batchResponse.newStrings === 0) {
      console.log(
        chalk.green('\n‚úÖ No new strings - using existing translations'),
      );
    } else {
      console.log(
        chalk.cyan(
          `\n‚è≥ Syncing to ${config.targetLocales.length} locales (${config.targetLocales.join(', ')})`,
        ),
      );

      if (batchResponse.estimatedTime) {
        console.log(
          chalk.dim(
            `   Estimated time: ~${batchResponse.estimatedTime} seconds`,
          ),
        );
      }
    }

    // 6. Poll for completion
    spinner.start('Waiting for translations to complete...');

    let lastProgress = 0;
    const result = await api.waitForCompletion(
      batchResponse.batchId,
      config.timeout,
      (progress) => {
        const percent = Math.round(progress * 100);
        if (percent > lastProgress) {
          spinner.text = `Syncing... ${percent}% complete`;
          lastProgress = percent;
        }
      },
    );

    const { translations, localeMetadata: apiLocaleMetadata } = result;
    spinner.succeed('Translations complete!');

    // 7. Write translations to cache (new structure: config.js + locale files)
    const vocoderDir = join(projectRoot, 'node_modules', '.vocoder');
    spinner.start('Writing translation files...');

    mkdirSync(vocoderDir, { recursive: true });

    // Write config.js with locale metadata
    const configContent = generateConfigModule(
      { sourceLocale: config.sourceLocale, targetLocales: config.targetLocales },
      apiLocaleMetadata,
    );
    writeFileSync(join(vocoderDir, 'config.js'), configContent, 'utf-8');

    // Write individual locale files (en.js, es.js, etc.)
    let totalSize = configContent.length;
    for (const [locale, strings] of Object.entries(translations)) {
      const localeContent = generateLocaleModule(locale, strings);
      writeFileSync(join(vocoderDir, `${locale}.js`), localeContent, 'utf-8');
      totalSize += localeContent.length;
    }

    // Write package.json so Node resolves require('.vocoder') correctly
    // Main entry points to config.js (not index.js anymore)
    writeFileSync(
      join(vocoderDir, 'package.json'),
      JSON.stringify({
        name: '.vocoder',
        version: '0.0.0',
        main: 'config.js',
        exports: {
          '.': './config.js',
          './config': './config.js',
          './*': './*.js'
        }
      }, null, 2),
      'utf-8',
    );

    const localeCount = Object.keys(translations).length;
    const totalStrings = Object.values(translations).reduce(
      (sum, strings) => sum + Object.keys(strings).length, 0
    );
    const sizeKB = (totalSize / 1024).toFixed(1);

    spinner.succeed(
      `Wrote ${chalk.cyan(localeCount)} locales (${chalk.cyan(totalStrings)} strings, ${sizeKB}KB)`,
    );

    // Success!
    const duration = ((Date.now() - startTime) / 1000).toFixed(1);
    console.log(
      chalk.green(`\n‚úÖ Sync complete! (${duration}s)\n`),
    );

    // Show next steps
    console.log(chalk.dim('Translations are loaded automatically by @vocoder/react.'));
    console.log(chalk.dim('No imports needed ‚Äî just use <VocoderProvider> and <T>.'));
    console.log(
      chalk.dim(
        '\nTip: Add "prebuild": "vocoder sync" to your package.json scripts.',
      ),
    );
  } catch (error) {
    if (error instanceof Error) {
      console.error(chalk.red(`\n‚ùå Error: ${error.message}\n`));

      // Show helpful error messages
      if (error.message.includes('VOCODER_API_KEY')) {
        console.log(chalk.yellow('üí° Solution:'));
        console.log(chalk.dim('   Set your API key:'));
        console.log(chalk.dim('   export VOCODER_API_KEY="your-api-key"'));
        console.log(chalk.dim('   or add it to your .env file'));
      } else if (error.message.includes('git branch')) {
        console.log(chalk.yellow('üí° Solution:'));
        console.log(chalk.dim('   Run from a git repository, or use:'));
        console.log(chalk.dim('   vocoder translate --branch main'));
      }

      if (options.verbose) {
        console.error(chalk.dim('\nFull error:'), error);
      }
    }

    process.exit(1);
  }
}
