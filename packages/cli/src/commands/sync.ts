import { mkdirSync, writeFileSync } from 'fs';
import { join, dirname } from 'path';
import chalk from 'chalk';
import ora from 'ora';
import { detectBranch, isTargetBranch } from '../utils/branch.js';
import { getLocalConfig, validateLocalConfig } from '../utils/config.js';
import { VocoderAPI } from '../utils/api.js';
import { StringExtractor } from '../utils/extract.js';
import type { TranslateOptions, ProjectConfig } from '../types.js';

/**
 * Generate index.ts file that auto-imports all locale files and creates a flat locales map (O(N))
 * Translated names are generated at runtime using Intl.DisplayNames
 */
function generateIndexFile(
  locales: string[],
  translations: Record<string, Record<string, string>>,
  localeMetadata?: Record<string, { nativeName: string; dir?: 'rtl' }>
): string {
  // Convert locale names to valid JS identifiers (replace hyphens with underscores)
  const toIdentifier = (locale: string) => locale.replace(/-/g, '_');

  const imports = locales.map(
    (locale: string) => `import ${toIdentifier(locale)} from './${locale}.json';`
  ).join('\n');

  const translationsObj = locales.map(
    (locale: string) => `  '${locale}': ${toIdentifier(locale)},`
  ).join('\n');

  // Build flat locales map (O(N) instead of O(N¬≤))
  // Use API-provided locale metadata if available, otherwise fallback to locale code
  const localesObjEntries = locales.map((locale: string) => {
    const metadata = localeMetadata?.[locale];

    if (metadata) {
      const escapedNativeName = metadata.nativeName.replace(/'/g, "\\'");
      const dirProp = metadata.dir ? `, dir: '${metadata.dir}' as const` : '';
      return `  '${locale}': { nativeName: '${escapedNativeName}'${dirProp} }`;
    } else {
      // Fallback: just use locale code as nativeName
      return `  '${locale}': { nativeName: '${locale}' }`;
    }
  });

  const localesObjString = localesObjEntries.join(',\n');

  return `// Auto-generated by Vocoder CLI
// This file imports all locale JSON files and exports them as a single object
// Usage: import { translations, locales } from './.vocoder/locales';

${imports}

export const translations = {
${translationsObj}
};

/**
 * Flat locale metadata map (O(N))
 * Structure: locales[localeCode] = { nativeName, dir? }
 * - nativeName: Name in the locale's own language (e.g., "Espa√±ol", "ÁÆÄ‰Ωì‰∏≠Êñá")
 * - dir: Optional 'rtl' for right-to-left locales
 *
 * Translated names are generated at runtime using Intl.DisplayNames:
 * Example: new Intl.DisplayNames(['es'], { type: 'language' }).of('en') ‚Üí "ingl√©s"
 * Display format: \`\${getDisplayName(code)} (\${locales[code].nativeName})\` ‚Üí "ingl√©s (English)"
 */
export const locales = {
${localesObjString}
};

export type SupportedLocale = ${locales.map((l: string) => `'${l}'`).join(' | ')};
`;
}

/**
 * Main sync command
 *
 * Workflow:
 * 1. Detect branch
 * 2. Load project config
 * 3. Check if target branch (skip if not)
 * 4. Extract strings from source code
 * 5. Submit to API for translation
 * 6. Poll for completion
 * 7. Write locale files to .vocoder/locales/
 */
export async function sync(options: TranslateOptions = {}): Promise<void> {
  const startTime = Date.now();
  const projectRoot = process.cwd();

  try {
    // 1. Detect branch
    const spinner = ora('Detecting branch...').start();
    const branch = detectBranch(options.branch);
    spinner.succeed(`Detected branch: ${chalk.cyan(branch)}`);

    // 2. Load local config and fetch project config from API
    spinner.start('Loading project configuration...');
    const localConfig = getLocalConfig();
    validateLocalConfig(localConfig);

    const api = new VocoderAPI(localConfig);
    const apiConfig = await api.getProjectConfig();

    // Merge local and API config
    const config: ProjectConfig = {
      ...localConfig,
      ...apiConfig,
      extractionPattern: process.env.VOCODER_EXTRACTION_PATTERN || 'src/**/*.{tsx,jsx,ts,js}',
      outputDir: '.vocoder/locales',
      timeout: 60000,
    };

    spinner.succeed('Project configuration loaded');

    // 3. Check if target branch
    if (!options.force && !isTargetBranch(branch, config.targetBranches)) {
      console.log(
        chalk.yellow(
          `‚ÑπÔ∏è  Skipping translations (${branch} is not a target branch)`,
        ),
      );
      console.log(
        chalk.dim(
          `   Target branches: ${config.targetBranches.join(', ')}`,
        ),
      );
      console.log(chalk.dim(`   Use --force to translate anyway`));
      process.exit(0);
    }

    // 4. Extract strings
    spinner.start(`Extracting strings from ${config.extractionPattern}...`);
    const extractor = new StringExtractor();
    const extractedStrings = await extractor.extractFromProject(
      config.extractionPattern,
      projectRoot,
    );

    if (extractedStrings.length === 0) {
      spinner.warn('No translatable strings found');
      console.log(chalk.yellow('Make sure you are using <T> components from @vocoder/react'));
      process.exit(0);
    }

    spinner.succeed(
      `Extracted ${chalk.cyan(extractedStrings.length)} strings from ${chalk.cyan(config.extractionPattern)}`,
    );

    // Show sample strings in verbose mode
    if (options.verbose) {
      console.log(chalk.dim('\nSample strings:'));
      extractedStrings.slice(0, 5).forEach((s) => {
        console.log(chalk.dim(`  - "${s.text}" (${s.file}:${s.line})`));
      });
      if (extractedStrings.length > 5) {
        console.log(chalk.dim(`  ... and ${extractedStrings.length - 5} more`));
      }
      console.log();
    }

    // Dry run mode - stop here
    if (options.dryRun) {
      console.log(chalk.cyan('\nüìã Dry run mode - would translate:'));
      console.log(chalk.dim(`   Strings: ${extractedStrings.length}`));
      console.log(chalk.dim(`   Branch: ${branch}`));
      console.log(chalk.dim(`   Target locales: ${config.targetLocales.join(', ')}`));
      console.log(chalk.dim(`\n   No API calls made.`));
      process.exit(0);
    }

    // 5. Submit to API
    spinner.start('Submitting strings to Vocoder API...');

    const strings = extractedStrings.map((s) => s.text);
    const batchResponse = await api.submitTranslation(
      branch,
      strings,
      config.targetLocales,
    );

    spinner.succeed(
      `Submitted to API - Batch ID: ${chalk.cyan(batchResponse.batchId)}`,
    );

    // Handle UP_TO_DATE status (hash matched, no changes)
    // Note: We still write locale files even when up-to-date, because
    // .vocoder/ might be gitignored and not present in the build environment
    if (batchResponse.status === 'UP_TO_DATE' && batchResponse.noChanges) {
      console.log(chalk.green('\n‚úî No changes detected - strings are up to date'));
      console.log(chalk.dim('   (Files will be written for build environment)\n'));
    }

    // Display diff metrics
    console.log(
      chalk.dim(
        `   New strings: ${chalk.cyan(batchResponse.newStrings)}`,
      ),
    );

    if (batchResponse.deletedStrings && batchResponse.deletedStrings > 0) {
      console.log(
        chalk.dim(
          `   Deleted strings: ${chalk.yellow(batchResponse.deletedStrings)} (archived)`,
        ),
      );
    }

    console.log(
      chalk.dim(
        `   Total strings: ${chalk.cyan(batchResponse.totalStrings)}`,
      ),
    );

    if (batchResponse.newStrings === 0) {
      console.log(
        chalk.green('\n‚úÖ No new strings - using existing translations'),
      );
      // Still fetch and write translations
    } else {
      console.log(
        chalk.cyan(
          `\n‚è≥ Syncing to ${config.targetLocales.length} locales (${config.targetLocales.join(', ')})`,
        ),
      );

      if (batchResponse.estimatedTime) {
        console.log(
          chalk.dim(
            `   Estimated time: ~${batchResponse.estimatedTime} seconds`,
          ),
        );
      }
    }

    // 6. Poll for completion
    spinner.start('Waiting for translations to complete...');

    let lastProgress = 0;
    const result = await api.waitForCompletion(
      batchResponse.batchId,
      config.timeout,
      (progress) => {
        const percent = Math.round(progress * 100);
        if (percent > lastProgress) {
          spinner.text = `Syncing... ${percent}% complete`;
          lastProgress = percent;
        }
      },
    );

    const { translations, localeMetadata: apiLocaleMetadata } = result;
    spinner.succeed('Translations complete!');

    // 7. Write locale files
    spinner.start(`Writing locale files to ${config.outputDir}...`);

    const outputPath = join(projectRoot, config.outputDir);
    mkdirSync(outputPath, { recursive: true });

    let filesWritten = 0;
    const localeNames: string[] = [];

    // Write locale files from API response (includes source locale now)
    for (const [locale, strings] of Object.entries(translations)) {
      const filePath = join(outputPath, `${locale}.json`);
      const content = JSON.stringify(strings, null, 2);

      // Ensure directory exists
      mkdirSync(dirname(filePath), { recursive: true });

      writeFileSync(filePath, content, 'utf-8');
      filesWritten++;
      localeNames.push(locale);

      const sizeKB = (content.length / 1024).toFixed(1);
      console.log(
        chalk.dim(`   ‚úì Wrote ${locale}.json (${sizeKB}KB)`),
      );
    }

    // Generate index file for auto-importing all locales (including source)
    const indexContent = generateIndexFile(localeNames, translations, apiLocaleMetadata);
    const indexPath = join(outputPath, 'index.ts');
    writeFileSync(indexPath, indexContent, 'utf-8');
    console.log(chalk.dim(`   ‚úì Generated index.ts (with flat locales map)`));

    spinner.succeed(`Wrote ${chalk.cyan(filesWritten)} locale files`);

    // Success!
    const duration = ((Date.now() - startTime) / 1000).toFixed(1);
    console.log(
      chalk.green(`\n‚úÖ Sync complete! (${duration}s)\n`),
    );

    // Show next steps
    console.log(chalk.dim('Next steps:'));
    console.log(
      chalk.dim(
        `   1. Import translations: import { translations } from '${config.outputDir}'`,
      ),
    );
    console.log(
      chalk.dim(
        `   2. Use VocoderProvider: <VocoderProvider translations={translations} defaultLocale="en">`,
      ),
    );
    console.log(
      chalk.dim(
        `   3. Commit ${config.outputDir}/ to your repository`,
      ),
    );
  } catch (error) {
    if (error instanceof Error) {
      console.error(chalk.red(`\n‚ùå Error: ${error.message}\n`));

      // Show helpful error messages
      if (error.message.includes('VOCODER_API_KEY')) {
        console.log(chalk.yellow('üí° Solution:'));
        console.log(chalk.dim('   Set your API key:'));
        console.log(chalk.dim('   export VOCODER_API_KEY="your-api-key"'));
        console.log(chalk.dim('   or add it to your .env file'));
      } else if (error.message.includes('git branch')) {
        console.log(chalk.yellow('üí° Solution:'));
        console.log(chalk.dim('   Run from a git repository, or use:'));
        console.log(chalk.dim('   vocoder translate --branch main'));
      }

      if (options.verbose) {
        console.error(chalk.dim('\nFull error:'), error);
      }
    }

    process.exit(1);
  }
}
