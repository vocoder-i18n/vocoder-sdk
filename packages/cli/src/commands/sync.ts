import type { ProjectConfig, TranslateOptions } from '../types.js';
import { detectBranch, isTargetBranch } from '../utils/branch.js';
import { getMergedConfig, validateLocalConfig } from '../utils/config.js';
import { mkdirSync, writeFileSync } from 'fs';

import { StringExtractor } from '../utils/extract.js';
import { VocoderAPI } from '../utils/api.js';
import chalk from 'chalk';
import { join } from 'path';
import ora from 'ora';

/**
 * Generate individual locale translation file
 */
function generateLocaleModule(
  locale: string,
  translations: Record<string, string>
): string {
  return `// Auto-generated by \`pnpm exec vocoder sync\` ‚Äî do not edit
// Translations for locale: ${locale}
module.exports = ${JSON.stringify(translations, null, 2)};
`;
}

function buildManifestConfig(
  projectConfig: { sourceLocale: string; targetLocales: string[] },
  localeMetadata?: Record<string, { nativeName: string; dir?: 'rtl' }>,
  locales: string[] = [],
): {
  allLocales: string[];
  config: { sourceLocale: string; targetLocales: string[]; locales: Record<string, { nativeName: string; dir?: string }> };
} {
  const allLocales = locales.length > 0
    ? locales
    : [projectConfig.sourceLocale, ...projectConfig.targetLocales];

  const localesObj: Record<string, { nativeName: string; dir?: string }> = {};
  for (const locale of allLocales) {
    const metadata = localeMetadata?.[locale];
    if (metadata) {
      localesObj[locale] = { nativeName: metadata.nativeName };
      if (metadata.dir) {
        localesObj[locale].dir = metadata.dir;
      }
    } else {
      localesObj[locale] = { nativeName: locale };
    }
  }

  return {
    allLocales,
    config: {
      sourceLocale: projectConfig.sourceLocale,
      targetLocales: projectConfig.targetLocales,
      locales: localesObj,
    },
  };
}

function generateManifestESM(
  config: { sourceLocale: string; targetLocales: string[]; locales: Record<string, { nativeName: string; dir?: string }> },
  locales: string[],
): string {
  const loaderLines = locales
    .map((locale) => `  ${JSON.stringify(locale)}: () => import('./${locale}.js'),`)
    .join('\n');

  return `// Auto-generated by \`pnpm exec vocoder sync\` ‚Äî do not edit
// ESM manifest for lazy locale loading
export const config = ${JSON.stringify(config, null, 2)};

export const loaders = {
${loaderLines}
};

export default { config, loaders };
`;
}

function generateManifestCJS(
  config: { sourceLocale: string; targetLocales: string[]; locales: Record<string, { nativeName: string; dir?: string }> },
  locales: string[],
): string {
  const loaderLines = locales
    .map((locale) => `  ${JSON.stringify(locale)}: () => require('./${locale}.js'),`)
    .join('\n');

  return `// Auto-generated by \`pnpm exec vocoder sync\` ‚Äî do not edit
// CJS manifest for SSR / Node
const config = ${JSON.stringify(config, null, 2)};

const loaders = {
${loaderLines}
};

module.exports = { config, loaders };
`;
}

/**
 * Main sync command
 *
 * Workflow:
 * 1. Detect branch
 * 2. Load project config
 * 3. Check if target branch (skip if not)
 * 4. Extract strings from source code
 * 5. Submit to API for translation
 * 6. Poll for completion
 * 7. Write translations to cache
 */
export async function sync(options: TranslateOptions = {}): Promise<number> {
  const startTime = Date.now();
  const projectRoot = process.cwd();

  try {
    // 1. Detect branch
    const spinner = ora('Detecting branch...').start();
    const branch = detectBranch(options.branch);
    spinner.succeed(`Detected branch: ${chalk.cyan(branch)}`);

    // 2. Load merged configuration from all sources
    spinner.start('Loading project configuration...');

    const mergedConfig = await getMergedConfig(options, options.verbose);
    const localConfig = {
      apiKey: mergedConfig.apiKey || '',
      apiUrl: mergedConfig.apiUrl || 'https://vocoder.app',
    };
    validateLocalConfig(localConfig);

    const api = new VocoderAPI(localConfig);
    const apiConfig = await api.getProjectConfig();

    // Merge local and API config
    const config: ProjectConfig = {
      ...localConfig,
      ...apiConfig,
      extractionPattern: mergedConfig.extractionPattern,
      excludePattern: mergedConfig.excludePattern,
      timeout: 60000,
    };

    spinner.succeed('Project configuration loaded');

    // 3. Check if target branch
    if (!options.force && !isTargetBranch(branch, config.targetBranches)) {
      console.log(
        chalk.yellow(
          `‚ÑπÔ∏è  Skipping translations (${branch} is not a target branch)`,
        ),
      );
      console.log(
        chalk.dim(
          `   Target branches: ${config.targetBranches.join(', ')}`,
        ),
      );
      console.log(chalk.dim(`   Use --force to translate anyway`));
      return 0;
    }

    // 4. Extract strings
    const patternsDisplay = Array.isArray(config.extractionPattern)
      ? config.extractionPattern.join(', ')
      : config.extractionPattern;

    spinner.start(`Extracting strings from ${patternsDisplay}...`);
    const extractor = new StringExtractor();
    const extractedStrings = await extractor.extractFromProject(
      config.extractionPattern,
      projectRoot,
      config.excludePattern,
    );

    if (extractedStrings.length === 0) {
      spinner.warn('No translatable strings found');
      console.log(chalk.yellow('Make sure you are using <T> components from @vocoder/react'));
      return 0;
    }

    spinner.succeed(
      `Extracted ${chalk.cyan(extractedStrings.length)} strings from ${chalk.cyan(patternsDisplay)}`,
    );

    // Show sample strings in verbose mode
    if (options.verbose) {
      console.log(chalk.dim('\nSample strings:'));
      extractedStrings.slice(0, 5).forEach((s) => {
        console.log(chalk.dim(`  - "${s.text}" (${s.file}:${s.line})`));
      });
      if (extractedStrings.length > 5) {
        console.log(chalk.dim(`  ... and ${extractedStrings.length - 5} more`));
      }
      console.log();
    }

    // Dry run mode - stop here
    if (options.dryRun) {
      console.log(chalk.cyan('\nüìã Dry run mode - would translate:'));
      console.log(chalk.dim(`   Strings: ${extractedStrings.length}`));
      console.log(chalk.dim(`   Branch: ${branch}`));
      console.log(chalk.dim(`   Target locales: ${config.targetLocales.join(', ')}`));
      console.log(chalk.dim(`\n   No API calls made.`));
      return 0;
    }

    // 5. Submit to API
    spinner.start('Submitting strings to Vocoder API...');

    const strings = extractedStrings.map((s) => s.text);
    const batchResponse = await api.submitTranslation(
      branch,
      strings,
      config.targetLocales,
    );

    spinner.succeed(
      `Submitted to API - Batch ID: ${chalk.cyan(batchResponse.batchId)}`,
    );

    // Handle UP_TO_DATE status (hash matched, no changes)
    if (batchResponse.status === 'UP_TO_DATE' && batchResponse.noChanges) {
      console.log(chalk.green('\n‚úî No changes detected - strings are up to date'));
    }

    // Display diff metrics
    console.log(
      chalk.dim(
        `   New strings: ${chalk.cyan(batchResponse.newStrings)}`,
      ),
    );

    if (batchResponse.deletedStrings && batchResponse.deletedStrings > 0) {
      console.log(
        chalk.dim(
          `   Deleted strings: ${chalk.yellow(batchResponse.deletedStrings)} (archived)`,
        ),
      );
    }

    console.log(
      chalk.dim(
        `   Total strings: ${chalk.cyan(batchResponse.totalStrings)}`,
      ),
    );

    if (batchResponse.newStrings === 0) {
      console.log(
        chalk.green('\n‚úÖ No new strings - using existing translations'),
      );
    } else {
      console.log(
        chalk.cyan(
          `\n‚è≥ Syncing to ${config.targetLocales.length} locales (${config.targetLocales.join(', ')})`,
        ),
      );

      if (batchResponse.estimatedTime) {
        console.log(
          chalk.dim(
            `   Estimated time: ~${batchResponse.estimatedTime} seconds`,
          ),
        );
      }
    }

    // 6. Poll for completion
    spinner.start('Waiting for translations to complete...');

    let lastProgress = 0;
    const result = await api.waitForCompletion(
      batchResponse.batchId,
      config.timeout,
      (progress) => {
        const percent = Math.round(progress * 100);
        if (percent > lastProgress) {
          spinner.text = `Syncing... ${percent}% complete`;
          lastProgress = percent;
        }
      },
    );

    const { translations, localeMetadata: apiLocaleMetadata } = result;

    // Ensure source locale exists (identity map) for consistent loading
    if (!translations[config.sourceLocale]) {
      translations[config.sourceLocale] = Object.fromEntries(
        strings.map((text) => [text, text]),
      );
    }
    spinner.succeed('Translations complete!');

    // 7. Write translations to generated package (manifest + locale files)
    const vocoderDir = join(projectRoot, 'node_modules', '@vocoder', 'generated');
    spinner.start('Writing translation files...');

    mkdirSync(vocoderDir, { recursive: true });

    // Write individual locale files (en.js, es.js, etc.)
    let totalSize = 0;
    for (const [locale, strings] of Object.entries(translations)) {
      const localeContent = generateLocaleModule(locale, strings);
      writeFileSync(join(vocoderDir, `${locale}.js`), localeContent, 'utf-8');
      totalSize += localeContent.length;
    }

    // Write ESM + CJS manifests
    const localeList = Object.keys(translations);
    const { allLocales, config: manifestConfig } = buildManifestConfig(
      { sourceLocale: config.sourceLocale, targetLocales: config.targetLocales },
      apiLocaleMetadata,
      localeList,
    );

    const manifestESM = generateManifestESM(manifestConfig, allLocales);
    const manifestCJS = generateManifestCJS(manifestConfig, allLocales);
    writeFileSync(join(vocoderDir, 'manifest.mjs'), manifestESM, 'utf-8');
    writeFileSync(join(vocoderDir, 'manifest.cjs'), manifestCJS, 'utf-8');
    totalSize += manifestESM.length + manifestCJS.length;

    // Write package.json so Node resolves @vocoder/generated correctly
    // Main entry points to manifest files
    writeFileSync(
      join(vocoderDir, 'package.json'),
      JSON.stringify({
        name: '@vocoder/generated',
        version: '0.0.0',
        private: true,
        main: 'manifest.cjs',
        exports: {
          '.': {
            import: './manifest.mjs',
            require: './manifest.cjs',
          },
          './manifest': {
            import: './manifest.mjs',
            require: './manifest.cjs',
          },
          './manifest.cjs': './manifest.cjs',
          './manifest.mjs': './manifest.mjs',
          './*': './*.js',
        }
      }, null, 2),
      'utf-8',
    );

    const localeCount = Object.keys(translations).length;
    const totalStrings = Object.values(translations).reduce(
      (sum, strings) => sum + Object.keys(strings).length, 0
    );
    const sizeKB = (totalSize / 1024).toFixed(1);

    spinner.succeed(
      `Wrote ${chalk.cyan(localeCount)} locales (${chalk.cyan(totalStrings)} strings, ${sizeKB}KB)`,
    );

    // Success!
    const duration = ((Date.now() - startTime) / 1000).toFixed(1);
    console.log(
      chalk.green(`\n‚úÖ Sync complete! (${duration}s)\n`),
    );

    // Show next steps
    console.log(chalk.dim('Translations are loaded automatically by @vocoder/react.'));
    console.log(chalk.dim('No imports needed ‚Äî just use <VocoderProvider> and <T>.'));
    console.log(
      chalk.dim(
        '\nTip: Add "prebuild": "vocoder sync" to your package.json scripts.',
      ),
    );
    return 0;
  } catch (error) {
    if (error instanceof Error) {
      console.error(chalk.red(`\n‚ùå Error: ${error.message}\n`));

      // Show helpful error messages
      if (error.message.includes('VOCODER_API_KEY')) {
        console.log(chalk.yellow('üí° Solution:'));
        console.log(chalk.dim('   Set your API key:'));
        console.log(chalk.dim('   export VOCODER_API_KEY="your-api-key"'));
        console.log(chalk.dim('   or add it to your .env file'));
      } else if (error.message.includes('git branch')) {
        console.log(chalk.yellow('üí° Solution:'));
        console.log(chalk.dim('   Run from a git repository, or use:'));
        console.log(chalk.dim('   vocoder sync --branch main'));
      }

      if (options.verbose) {
        console.error(chalk.dim('\nFull error:'), error);
      }
    }
    return 1;
  }
}
